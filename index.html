<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmo dijkstra</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: Arial, sans-serif;
    }

    .contenedor {
      background: white;
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
    }

    .laberinto {
      display: inline-block;
      border: 2px solid #333;
      background: #f0f0f0;
    }

    .fila {
      display: flex;
    }

    .celda {
      width: 30px;
      height: 30px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }

    .pared {
      background: #333;
      color: white;
    }

    .camino {
      background: #fff;
    }

    .inicio {
      background: #4CAF50;
      color: white;
    }

    .fin {
      background: #f44336;
      color: white;
    }

    .botones {
      margin-top: 20px;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 0 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
    }

    button:hover {
      background: #5a6fd8;
    }

    .info {
      margin-top: 15px;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="contenedor">
    <h1>Generador de Laberinto</h1>
    <div id="laberinto" class="laberinto"></div>
    <div class="botones">
      <button onclick="generarLaberinto()">Generar Nuevo Laberinto</button>
      <button onclick="resolverLaberinto()">Resolver con Dijkstra</button>
    </div>
    <div class="info">
      <p>ðŸŸ¢ Inicio | ðŸ”´ Fin | â¬› Pared | â¬œ Camino</p>
    </div>
  </div>

  <script>
    let laberinto = [];
    const filas = 25;
    const columnas = 25;
    let inicio = { fila: 1, columna: 1 };
    let fin = { fila: filas - 2, columna: columnas - 2 };

    function inicializarLaberinto() {
      laberinto = [];
      for (let i = 0; i < filas; i++) {
        laberinto[i] = [];
        for (let j = 0; j < columnas; j++) {
          laberinto[i][j] = Math.random() < 0.3 ? 1 : 0; // 30% de probabilidad de pared
        }
      }
      
      // Asegurar que inicio y fin sean caminos
      laberinto[inicio.fila][inicio.columna] = 0;
      laberinto[fin.fila][fin.columna] = 0;
      
      // Crear un camino bÃ¡sico
      crearCaminoBasico();
    }

    function crearCaminoBasico() {
      // Crear un camino simple desde inicio hasta fin
      let fila = inicio.fila;
      let columna = inicio.columna;
      
      while (fila !== fin.fila || columna !== fin.columna) {
        if (fila < fin.fila) {
          fila++;
          laberinto[fila][columna] = 0;
        } else if (fila > fin.fila) {
          fila--;
          laberinto[fila][columna] = 0;
        }
        
        if (columna < fin.columna) {
          columna++;
          laberinto[fila][columna] = 0;
        } else if (columna > fin.columna) {
          columna--;
          laberinto[fila][columna] = 0;
        }
      }
    }

    function renderizarLaberinto() {
      const contenedor = document.getElementById('laberinto');
      contenedor.innerHTML = '';
      
      for (let i = 0; i < filas; i++) {
        const fila = document.createElement('div');
        fila.className = 'fila';
        
        for (let j = 0; j < columnas; j++) {
          const celda = document.createElement('div');
          celda.className = 'celda';
          
          if (i === inicio.fila && j === inicio.columna) {
            celda.className += ' inicio';
            celda.textContent = 'I';
          } else if (i === fin.fila && j === fin.columna) {
            celda.className += ' fin';
            celda.textContent = 'F';
          } else if (laberinto[i][j] === 1) {
            celda.className += ' pared';
            celda.textContent = 'â¬›';
          } else {
            celda.className += ' camino';
            celda.textContent = 'â¬œ';
          }
          
          fila.appendChild(celda);
        }
        
        contenedor.appendChild(fila);
      }
    }

    function generarLaberinto() {
      inicializarLaberinto();
      renderizarLaberinto();
    }

    function resolverLaberinto() {
      // ImplementaciÃ³n bÃ¡sica del algoritmo de Dijkstra
      const distancias = [];
      const visitados = [];
      const previos = [];
      
      // Inicializar arrays
      for (let i = 0; i < filas; i++) {
        distancias[i] = [];
        visitados[i] = [];
        previos[i] = [];
        for (let j = 0; j < columnas; j++) {
          distancias[i][j] = Infinity;
          visitados[i][j] = false;
          previos[i][j] = null;
        }
      }
      
      // Distancia del inicio a sÃ­ mismo es 0
      distancias[inicio.fila][inicio.columna] = 0;
      
      const cola = [{ fila: inicio.fila, columna: inicio.columna, distancia: 0 }];
      
      while (cola.length > 0) {
        cola.sort((a, b) => a.distancia - b.distancia);
        const actual = cola.shift();
        
        if (visitados[actual.fila][actual.columna]) continue;
        visitados[actual.fila][actual.columna] = true;
        
        // Si llegamos al final
        if (actual.fila === fin.fila && actual.columna === fin.columna) {
          break;
        }
        
        // Explorar vecinos
        const direcciones = [
          { fila: -1, columna: 0 }, // Arriba
          { fila: 1, columna: 0 },  // Abajo
          { fila: 0, columna: -1 }, // Izquierda
          { fila: 0, columna: 1 }   // Derecha
        ];
        
        for (const dir of direcciones) {
          const nuevaFila = actual.fila + dir.fila;
          const nuevaColumna = actual.columna + dir.columna;
          
          if (nuevaFila >= 0 && nuevaFila < filas && 
              nuevaColumna >= 0 && nuevaColumna < columnas &&
              laberinto[nuevaFila][nuevaColumna] === 0 &&
              !visitados[nuevaFila][nuevaColumna]) {
            
            const nuevaDistancia = actual.distancia + 1;
            
            if (nuevaDistancia < distancias[nuevaFila][nuevaColumna]) {
              distancias[nuevaFila][nuevaColumna] = nuevaDistancia;
              previos[nuevaFila][nuevaColumna] = { fila: actual.fila, columna: actual.columna };
              cola.push({ fila: nuevaFila, columna: nuevaColumna, distancia: nuevaDistancia });
            }
          }
        }
      }
      
      // Reconstruir el camino
      const camino = [];
      let actual = { fila: fin.fila, columna: fin.columna };
      
      while (actual !== null) {
        camino.unshift(actual);
        actual = previos[actual.fila][actual.columna];
      }
      
      // Mostrar el camino
      mostrarCamino(camino);
    }

    function mostrarCamino(camino) {
      const celdas = document.querySelectorAll('.celda');
      
      // Limpiar camino anterior
      celdas.forEach(celda => {
        if (celda.textContent === 'ðŸŸ¡') {
          celda.textContent = 'â¬œ';
          celda.style.background = '#fff';
        }
      });
      
      // Mostrar nuevo camino
      camino.forEach((pos, index) => {
        if (index > 0 && index < camino.length - 1) { // No cambiar inicio ni fin
          const indice = pos.fila * columnas + pos.columna;
          celdas[indice].textContent = 'ðŸŸ¡';
          celdas[indice].style.background = '#FFD700';
        }
      });
      
      alert(`Camino encontrado! Distancia: ${camino.length - 1} pasos`);
    }

    // Generar laberinto inicial al cargar la pÃ¡gina
    window.onload = function() {
      generarLaberinto();
    };
  </script>
</body>
</html>